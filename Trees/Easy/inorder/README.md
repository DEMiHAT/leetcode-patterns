### **Binary Tree Inorder Traversal**#### **Intuition**Inorder traversal follows the rule: **Left $\rightarrow$ Root $\rightarrow$ Right**.While a recursive solution is trivial, an iterative solution must manually replicate the behavior of the function call stack. We use an explicit **Stack** to keep track of the nodes we need to return to.The core idea is:1.  Go as far left as possible, pushing each node onto the stack as we descend.2.  When we hit `NULL` (can't go left anymore), we "visit" the last node by popping it from the stack and adding its value to our result.3.  After visiting a node, we move to its **right** child and repeat the process (go left from there).#### **Approach (Iterative C Solution)**1.  **Initialization:**      * Allocate memory for the `result` array (size 100, based on constraints).      * Allocate memory for our explicit `stack` (size 100).      * Initialize the stack pointer `top` to -1 (empty).      * Create a `current` pointer and set it to `root`.2.  **Traversal Loop:**      * Start a `while` loop that continues as long as `current` is not `NULL` (we still have nodes to explore) **or** the `stack` is not empty (`top != -1`, meaning we have nodes to visit).3.  **Phase 1: Go Left:**      * Inside the loop, run an inner `while` loop: as long as `current` is not `NULL`, push `current` onto the stack (`stack[++top] = current`) and move left (`current = current->left`).4.  **Phase 2: Visit Root and Go Right:**      * When the inner loop finishes, `current` is `NULL`. Pop the last node from the stack (`current = stack[top--]`).      * "Visit" this node by adding its value to the result (`result[(*returnSize)++] = current->val`).      * Move to the right child (`current = current->right`) to begin the process again for the right subtree.5.  **Cleanup:** Once the outer loop terminates, `free` the stack and return the `result` array.#### **Complexity Analysis**  * **Time Complexity:** $O(n)$      * Each node in the tree is pushed onto the stack exactly once and popped from the stack exactly once.  * **Space Complexity:** $O(h)$      * where $h$ is the height of the tree. This is the maximum memory used by our explicit `stack`. In the worst case (a skewed tree), this can be $O(n)$.-----### **Problem Link**https://leetcode.com/problems/binary-tree-inorder-traversal/description/